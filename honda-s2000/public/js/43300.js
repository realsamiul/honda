// This file was generated by Slater.app - vtec.js


gsap.registerPlugin(SplitText, ScrollTrigger, CustomEase, ScrambleTextPlugin);
let textEase = "M0,0 C0.312,0.153 0.387,0.326 0.495,0.509 0.593,0.676 0.684,1.017 1,1 "
let ease = "M0,0 C0.7,0.024 0.199,0.976 1,1 ";

// loader

function loader() {
  let counter = {
    value: 0
  };
  let ease = "M0,0 C0.7,0.024 0.199,0.976 1,1 ";

  function loaderNum() {
    let progress = Math.round(counter.value);
    $(".loader-gauge-text").text(progress);
  };

  const item = document.querySelectorAll(".loader-item")

  function display() {
    gsap.set(".loader", { display: "none" })
  }

  function endLoader() {
    let tl = gsap.timeline();

    tl.to(".loader-gauge", {
        y: "-70vh",
        duration: 1.2,
        ease: ease
      })
      .to(item, {
        yPercent: -100,
        stagger: { amount: .2, from: "random" },
        duration: 1.2,
        ease: ease,
        onComplete: () => {
          display();
        }
      }, 0)
      .to("[load-overlay]", {
        opacity: 0,
        duration: 1
      }, 0)
      .call(home, null, "-=1.2")
  }

  let tl = gsap.timeline({
    onComplete: () => {
      // Reverse gauge bars rapidly
      gsap.to(".loader-gauge-anim", {
        fill: "#292929", // or original color
        stagger: { each: 0.01, from: "end" }, // reverses from right to left
        ease: "power4.inOut",
        duration: 0.06, // much faster
      });

      gsap.to(counter, {
        onUpdate: loaderNum,
        value: 0,
        duration: 0.5, // much faster
        ease: "power4.inOut",
        onComplete: () => {
          endLoader();
        }
      });
    }
  });

  tl.to(counter, {
      delay: .15,
      onUpdate: loaderNum,
      ease: "power4.inOut",
      value: 100,
      duration: 2,
    }, 0)
    .to(".loader-gauge-anim", {
      delay: .3,
      fill: "#FF7700",
      stagger: .03,
      ease: "power4.inOut",
      from: "left",
      duration: .1,
    }, 0)

}
// loader();

function gauge() {
  const wrap = document.querySelector(".progress-gauge")
  const gauge = document.querySelectorAll(".gauge-dial")
  const anim = document.querySelector(".gauge-anims-wrap")
  let ease = "M0,0 C0.736,0 0.241,1 1,1 ";
  let tl = gsap.timeline();
  let mph = {
    value: 0
  };

  function mphNum() {
    let progress = Math.round(mph.value);
    $("[gauge-progress]").text(progress);
  };

  gsap.set(wrap, {
    yPercent: 130
  })
  gsap.set(anim, {
    translateY: 130
  })

  gsap.to(wrap, {
    yPercent: 0,
    duration: .5,
    ease: ease,
    scrollTrigger: {
      trigger: ".hero",
      start: "bottom -5%",
      toggleActions: "play reverse play reverse",
      endTrigger: ".overlay2",
    }
  })

  gsap.to(anim, {
    translateY: 0,
    duration: .5,
    ease: ease,
    scrollTrigger: {
      trigger: ".hero",
      start: "bottom -5%",
      toggleActions: "play reverse play reverse",
      endTrigger: ".overlay2",
    }
  })

  gsap.to(mph, {
    onUpdate: mphNum,
    ease: ease,
    value: 100,
    scrollTrigger: {
      scrub: true,
      trigger: ".hero",
      start: "bottom bottom",
      end: "bottom -120%",
      toggleActions: "play reverse play reverse",
      endTrigger: ".overlay2",
    }
  })

  gsap.to(gauge, {
    fill: "#FF7700",
    stagger: .1,
    ease: ease,
    from: "left",
    scrollTrigger: {
      scrub: true,
      trigger: ".hero",
      start: "bottom bottom",
      // end: "bottom -90%",
      toggleActions: "play reverse play reverse",
      endTrigger: ".overlay2",
    }
  })
}
gauge()

function nav() {

  gsap.set('.progress-nav', {
    xPercent: -100
  })

  gsap.to('.progress-nav', {
    xPercent: 0,
    duration: .6,
    ease: ease,
    scrollTrigger: {
      trigger: ".hero",
      start: "bottom -5%",
      toggleActions: "play reverse play reverse",
      endTrigger: ".overlay2",
    }
  })
  let navProgress = document.querySelector('[data-progress-nav-list]');

  // Create or select the moving indicator
  let indicator = navProgress.querySelector('.progress-nav__indicator');
  if (!indicator) {
    indicator = document.createElement('div');
    indicator.className = 'progress-nav__indicator';
    navProgress.appendChild(indicator);
  }

  // Function to update the indicator based on the active nav link
  function updateIndicator(activeLink) {
    let parentWidth = navProgress.offsetWidth;
    let parentHeight = navProgress.offsetHeight;

    // Get the active link's position relative to the parent
    let parentRect = navProgress.getBoundingClientRect();
    let linkRect = activeLink.getBoundingClientRect();
    let linkPos = {
      left: linkRect.left - parentRect.left,
      top: linkRect.top - parentRect.top
    };

    let linkWidth = activeLink.offsetWidth;
    let linkHeight = activeLink.offsetHeight;

    // Calculate percentage values relative to parent dimensions
    let leftPercent = (linkPos.left / parentWidth) * 100;
    let topPercent = (linkPos.top / parentHeight) * 100;
    let widthPercent = (linkWidth / parentWidth) * 100;
    let heightPercent = (linkHeight / parentHeight) * 100;

    // Update the indicator with a smooth CSS transition (set in your CSS)
    indicator.style.left = leftPercent + '%';
    indicator.style.top = topPercent + '%';
    // indicator.style.width = widthPercent + '%';
    indicator.style.height = heightPercent + '%';
  }

  // Get all anchor sections
  let progressAnchors = gsap.utils.toArray('[data-progress-nav-anchor]');

  progressAnchors.forEach((progressAnchor) => {
    let anchorID = progressAnchor.getAttribute('id');

    ScrollTrigger.create({
      trigger: progressAnchor,
      start: '0% 50%',
      end: '100% 50%',
      onEnter: () => {
        let activeLink = navProgress.querySelector('[data-progress-nav-target="#' +
          anchorID + '"]');
        activeLink.classList.add('is--active');
        // Remove 'is--active' class from sibling links
        let siblings = navProgress.querySelectorAll('[data-progress-nav-target]');
        siblings.forEach((sib) => {
          if (sib !== activeLink) {
            sib.classList.remove('is--active');
          }
        });
        updateIndicator(activeLink);
      },
      onEnterBack: () => {
        let activeLink = navProgress.querySelector('[data-progress-nav-target="#' +
          anchorID + '"]');
        activeLink.classList.add('is--active');
        // Remove 'is--active' class from sibling links
        let siblings = navProgress.querySelectorAll('[data-progress-nav-target]');
        siblings.forEach((sib) => {
          if (sib !== activeLink) {
            sib.classList.remove('is--active');
          }
        });
        updateIndicator(activeLink);
      }
    });
  });

}
// nav()

// home animation 
function home() {
  const herochar = document.querySelectorAll("[hero-char]")
  const herochar2 = document.querySelectorAll("[hero-char2]")
  const num = document.querySelectorAll("[hero-num]")
  // var split = SplitText.create(heading, { types: "chars" })
  // const chars = split.chars;

  let tl = gsap.timeline();

  gsap.from("[herowrap]", {
    yPercent: 105,
    rotateZ: 20,
    delay: .2,
    duration: 1.3,
    ease: ease,
  })

  tl.from(herochar, {
      yPercent: 102,
      // rotateX: 0,
      delay: .2,
      duration: 1,
      stagger: .09,
      ease: ease,
    })
    .from(herochar2, {
      yPercent: 102,
      // rotateX: 0,
      delay: .3,
      duration: 1.4,
      stagger: .09,
      ease: ease,
    }, 0)

  // text scrolltrig up

  herochar.forEach((el) => {
    gsap.fromTo(herochar, {
      yPercent: 0,
      rotateZ: 0,
    }, {
      yPercent: -110,
      rotateZ: 10,
      stagger: .09,
      scrollTrigger: {
        scrub: true,
        trigger: ".hero",
        start: "bottom center",
        end: "+=100%",
      }
    })
  })

  herochar2.forEach((el) => {
    gsap.fromTo(herochar2, {
      yPercent: 0,
      rotateZ: 0,
    }, {
      yPercent: -100,
      rotateZ: 10,
      stagger: .09,
      scrollTrigger: {
        scrub: true,
        trigger: ".hero",
        start: "bottom 30%",
        end: "+=100%",
      }
    })
  })

  num.forEach((el) => {
    gsap.fromTo(num, {
      yPercent: 0,
      rotation: 0,
    }, {
      yPercent: -120,
      rotation: 9,
      stagger: .07,
      scrollTrigger: {
        scrub: true,
        trigger: ".hero",
        start: "bottom 30%",
        end: "+=100%",
      }
    })
  })

  gsap.to(".dash", {
    scaleX: { amount: 0, from: "right" },
    scrollTrigger: {
      scrub: 1,
      trigger: ".hero",
      start: "bottom 30%",
      end: "+=100%",
    }
  })

  // home text anim

  gsap.to("[heroabout]", {
    delay: 1,
    duration: 1,
    scrambleText: {
      text: "A tribute to the engineering, design,",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
    },
  })
  gsap.to("[heroabout2]", {
    delay: 3.7,
    duration: 1,
    scrambleText: {
      text: "and culture of Honda’s iconic roadster.",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
    },
  }, 0)
  gsap.to("[heroabout2]", {
    delay: .7,
    duration: 1,
    scrambleText: {
      text: "and culture of Honda’s iconic roadster.",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
    },
  }, 0)

  gsap.to("[hero-gear]", {
    duration: .6,
    stagger: .1,
    scrambleText: {
      text: "{original}",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
    }
  });
}
// home()

// heading anim

function heading() {
  // function mainHead() {

  let mm = gsap.matchMedia();
  mm.add("(min-width: 768px)", () => {
    const heading = document.querySelectorAll("[heading]")

    heading.forEach((head) => {
      let tl = gsap.timeline({
        scrollTrigger: {
          trigger: head,
          start: "top 100%",
          // markers: true,

        }
      });
      let whiteChars = SplitText.create(head, { type: "chars" }).chars;

      tl.to(whiteChars, {
        yPercent: -100,
        delay: .04,
        duration: .75,
        stagger: .02,
        ease: ease,
      })
    });
    // }

    const orange = document.querySelectorAll("[orange]")

    orange.forEach((orange) => {

      let tl2 = gsap.timeline({
        scrollTrigger: {
          trigger: orange,
          start: "top 100%",
        }
      });

      let orangeChars = SplitText.create(orange, { type: "chars" }).chars;

      tl2.to(orangeChars, {
        yPercent: -100,
        delay: .065,
        duration: .75,
        stagger: .02,
        ease: ease,

      })
    });
  })

  // gsap.to(orange, {
  //   delay: .065,
  //   ease: textEase,
  //   scrollTrigger: {
  //     scrub: 2,
  //     trigger: "artistry",
  //     start: "top top",
  //     end: "bottom bottom",
  //   }
  // })

}

// gear text

function gears() {

  const gear = document.querySelectorAll("[gearText]")

  gear.forEach((el) => {
    gsap.to(el, {
      duration: .5,
      scrambleText: {
        text: "{original}",
        chars: " ",
        speed: .6,
        tweenLength: false,
        rightToLeft: false,
      },
      scrollTrigger: {
        trigger: el,
        start: "top 100%",
        end: "+=100%",
      }
    });
  });
}

// brief anim

function briefAnim() {

  //2klogo

  gsap.utils.toArray('[logopath]').forEach(path => {
    const length = path.getTotalLength();
    path.style.strokeDasharray = length;
    path.style.strokeDashoffset = length;

    gsap.to(path, {
      strokeDashoffset: 0,
      duration: 1.3,
      stagger: .2,
      scrollTrigger: {
        trigger: path, // Animate when line enters viewport
        start: "top 80%",
        end: "bottom 40%",
        scrub: 1 // Scroll-based for interactive reveal
      }
    })
  })

  let mm = gsap.matchMedia();
  mm.add("(min-width: 768px)", () => {
    // para
    const para = document.querySelectorAll("[p-opacity]");
    var split = SplitText.create(para, { type: 'words, chars' });
    const chars = split.chars;

    gsap.from(chars, {
      opacity: .25,
      stagger: .4,
      ease: "none",
      scrollTrigger: {
        trigger: ".brief",
        start: "top top",
        end: "bottom 100%",
        scrub: .3,
      }
    })

  })

  mm.add("(max-width: 768px)", () => {

    const para = document.querySelectorAll("[p-opacity]");
    var split = SplitText.create(para, { type: 'words, chars' });
    const chars = split.chars;
    gsap.from(chars, {
      opacity: .25,
      stagger: .4,
      ease: "none",
      scrollTrigger: {
        trigger: ".brief",
        start: "top top",
        end: "+=100%",
        scrub: .2,
      }
    })

    gsap.utils.toArray('[logopath]').forEach(path => {
      const length = path.getTotalLength();
      path.style.strokeDasharray = length;
      path.style.strokeDashoffset = length;

      gsap.to(path, {
        strokeDashoffset: 0,
        duration: 1.3,
        stagger: .2,
        scrollTrigger: {
          trigger: path, // Animate when line enters viewport
          start: "top 80%",
          end: "+=60%",
          scrub: 1 // Scroll-based for interactive reveal
        }
      })
    })
  })
}

// legacy vid

function legacy() {
  const video = document.getElementById("legacyvid");
  const art = document.querySelector(".artistry");

  if (art) {
    LottieScrollTrigger({
      trigger: art,
      start: "top top",
      end: "bottom bottom",
      scrub: 2,
      target: ".animation",
      path: "https://cdn.prod.website-files.com/687891a1de8273e3ce3ef3c0/687c97ffcf02b40319ebbab6_lottie.json",
      renderer: "svg",
    });
  }

  function LottieScrollTrigger(vars) {
    const playhead = { frame: 0 };
    const target = gsap.utils.toArray(vars.target)[0];
    const speeds = { slow: "+=2000", medium: "+=1000", fast: "+=500" };

    const st = {
      trigger: ".trigger",
      end: speeds[vars.speed] || "+=1000",
      scrub: 1,
      markers: false,
    };

    // Copy vars into st config (like trigger/start/end/scrub)
    for (let p in vars) {
      st[p] = vars[p];
    }

    const ctx = gsap.context && gsap.context();

    const animation = lottie.loadAnimation({
      container: target,
      renderer: vars.renderer || "svg",
      loop: false,
      autoplay: false,
      path: vars.path,
      rendererSettings: vars.rendererSettings || {
        preserveAspectRatio: "xMidYMid slice",
      },
    });

    animation.addEventListener("DOMLoaded", function () {
      const createTween = function () {
        animation.frameTween = gsap.to(playhead, {
          frame: animation.totalFrames - 1,
          ease: "none",
          onUpdate: () => animation.goToAndStop(playhead.frame, true),
          scrollTrigger: st,
        });
      };

      // Use GSAP context if available (optional Webflow compatibility)
      ctx && ctx.add ? ctx.add(createTween) : createTween();
    });

    return animation;
  }
}

// milestones anim

function mile() {
  const motionText = document.querySelectorAll('[motion1]')
  const skew = document.querySelectorAll('[skew]')
  gsap.from(motionText, {
    translateX: "-180%",
    stagger: -.005,
    scrollTrigger: {
      trigger: '.milestones',
      start: "top bottom",
      end: "+=140%",
      scrub: .6,
    }
  })

  gsap.to('.f-arrow', {
    duration: 1,
    delay: .5,
    ease: "power4.inOut",
    translateX: "100%",
    scrollTrigger: {
      trigger: '.milestones',
    },
    onComplete: ScrollTrigger.refresh()

  })

  let proxy = { skew: 0 };
  const skewSetter = gsap.quickSetter(skew, "skewX", "deg");

  ScrollTrigger.create({
    onUpdate: (self) => {
      // Calculate skew based on scroll velocity (adjust divisor for intensity)
      let skewAmount = self.getVelocity() / -150;
      // Clamp to avoid excessive skew
      skewAmount = gsap.utils.clamp(-20, 20, skewAmount);
      // Only update if the new skew is larger in magnitude
      if (Math.abs(skewAmount) > Math.abs(proxy.skew)) {
        proxy.skew = skewAmount;
        gsap.to(proxy, {
          skew: 0,
          duration: 0.8,
          ease: "power3",
          overwrite: true,
          onUpdate: () => skewSetter(proxy.skew)
        });
      }
    }
  });

  // specs

  const specs1 = document.querySelectorAll("[spec1]")
  const specs2 = document.querySelectorAll("[spec]")

  gsap.to(specs1, {
    duration: .6,
    stagger: .07,
    scrambleText: {
      text: "{original}",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
    },
    scrollTrigger: {
      trigger: '.m-content',
    }
  })

  gsap.to(specs2, {
    delay: .2,
    duration: .6,
    stagger: .07,
    scrambleText: {
      text: "{original}",
      chars: " ",
      speed: .6,
      tweenLength: false,
      rightToLeft: false,
      // revealDelay: .3
    },
    scrollTrigger: {
      trigger: '[ap-specs]',
    },
    onComplete: ScrollTrigger.refresh()
  })
}

// analog anims 

function analog() {
  // ScrollTrigger.refresh()
  const outline = document.querySelector('[outline]')
  const shifter = document.querySelector('[shifter]')
  const wrap = document.querySelector('.analog')
  const skewText = document.querySelectorAll('[text-skew]')

  gsap.to(outline, {
    xPercent: -30,
    scrollTrigger: {
      trigger: wrap,
      scrub: true,
      start: "center center",
      end: "+=300%",
    }
  })
  gsap.to(shifter, {
    y: "355",
    duration: .7,
    ease: CustomEase.create("custom", "M0,0 C0.736,0 0.429,1 1,1 "),
    scrollTrigger: {
      trigger: wrap,
      start: "top 25%",
      toggleActions: "play reverse play reverse"
    }
  })

  let mm = gsap.matchMedia();
  mm.add("(max-width: 768px)", () => {
    const wrap = document.querySelector('.analog')

    gsap.to(shifter, {
      y: "355",
      duration: .7,
      ease: CustomEase.create("custom", "M0,0 C0.736,0 0.429,1 1,1 "),
      scrollTrigger: {
        trigger: wrap,
        start: "top center",
        end: "+=100%",
        toggleActions: "play reverse",
      },
      onComplete: ScrollTrigger.refresh()

    })

  })

  // skew anim

  let proxy = { skew: 0 };
  const skewSetter = gsap.quickSetter(skewText, "skewX", "deg");

  mm.add("(min-width: 768px)", () => {
    ScrollTrigger.create({
      onUpdate: (self) => {
        // Calculate skew based on scroll velocity (adjust divisor for intensity)
        let skewAmount = self.getVelocity() / -100;
        // Clamp to avoid excessive skew
        skewAmount = gsap.utils.clamp(-20, 20, skewAmount);
        // Only update if the new skew is larger in magnitude
        if (Math.abs(skewAmount) > Math.abs(proxy.skew)) {
          proxy.skew = skewAmount;
          gsap.to(proxy, {
            skew: 0,
            duration: 0.8,
            ease: "power3",
            overwrite: true,
            onUpdate: () => skewSetter(proxy.skew)
          });
        }
      }
    });

    const analogScroll = document.querySelector(".analog-scroll");
    const analogWraps = gsap.utils.toArray(".analog-wrap");

    let totalWidth = 0;
    analogWraps.forEach(el => {
      totalWidth += el.offsetWidth;
    });

    const scrollDistance = totalWidth - window.innerWidth;
    const analog = document.querySelector(".analog");
    analog.style.height = `${window.innerHeight + scrollDistance / 20}px`;

    gsap.to(analogWraps, {
      x: -scrollDistance,
      ease: "none",
      scrollTrigger: {
        trigger: '.analog',
        start: "top top",
        // end: `+=${scrollDistance}`,
        pin: true,
        scrub: 1,
        invalidateOnRefresh: true
      },
    });
  })
}
// window.addEventListener('load', analog);
// window.addEventListener('resize', () => {
//   ScrollTrigger.refresh();
//   analog();
// });

// blueprint/under the surface anims 

function blueprint() {
  const outline1 = document.querySelector('[s2koutline1]')
  const outline2 = document.querySelector('[s2koutline2]')

  const s2k = document.querySelector('.s-outline')
  const paths = s2k.querySelectorAll('path')

  const s2k2 = document.querySelector('.s-outline2')
  const paths2 = s2k2.querySelectorAll('path')

  gsap.utils.toArray(paths).forEach(path => {
    const length = path.getTotalLength();
    path.style.strokeDasharray = length;
    path.style.strokeDashoffset = length;

    gsap.to(path, {
      strokeDashoffset: 1,
      scrollTrigger: {
        trigger: '.under-wrap',
        start: "top 20%",
        end: "+=120%",
        // markers: true,
        scrub: 1
      }
    })
  })

  gsap.to(s2k, {
    opacity: 0,
    scrollTrigger: {
      trigger: '.under',
      start: "center 100%",
      end: "+=60%",
      scrub: true,
    }
  })

  gsap.utils.toArray(paths2).forEach(path => {
    const length = path.getTotalLength();
    path.style.strokeDasharray = length;
    path.style.strokeDashoffset = length;

    gsap.to(path, {
      strokeDashoffset: 1,
      stagger: .2,
      scrollTrigger: {
        trigger: '.under',
        start: "center center",
        end: "+=120%",
        scrub: 1,
      }
    })
  })

  gsap.utils.toArray(paths2).forEach(path => {
    const length = path.getTotalLength();
    path.style.strokeDasharray = length;
    path.style.strokeDashoffset = length;

    gsap.to(path, {
      stroke: "#a0a0a0",
      stagger: .2,
      scrollTrigger: {
        trigger: '.under',
        start: "center -60%",
        end: "+=120%",
        scrub: 1,
      }
    })
  })

  let mm = gsap.matchMedia();
  mm.add("(max-width: 768px)", () => {

    gsap.utils.toArray(paths).forEach(path => {
      const length = path.getTotalLength();
      path.style.strokeDasharray = length;
      path.style.strokeDashoffset = length;

      gsap.to(path, {
        stroke: "#666666",
        strokeDashoffset: 1,
        scrollTrigger: {
          trigger: '.under',
          start: "top 20%",
          end: "+=120%",
          // markers: true,
          scrub: 1
        }
      })
    })

    gsap.to(s2k, {
      opacity: 0,
      scrollTrigger: {
        trigger: '.under',
        start: "center 100%",
        end: "+=60%",
        scrub: true,
      }
    })

    gsap.utils.toArray(paths2).forEach(path => {
      const length = path.getTotalLength();
      path.style.strokeDasharray = length;
      path.style.strokeDashoffset = length;

      gsap.to(path, {
        stroke: "#666666",

        strokeDashoffset: 1,
        stagger: .2,
        scrollTrigger: {
          trigger: '.under',
          start: "center center",
          end: "+=120%",
          scrub: 1,
        }
      })
    })

    gsap.utils.toArray(paths2).forEach(path => {
      const length = path.getTotalLength();
      path.style.strokeDasharray = length;
      path.style.strokeDashoffset = length;

      gsap.to(path, {
        stroke: "#b3b3b3",
        stagger: .2,
        scrollTrigger: {
          trigger: '.under',
          start: "center -60%",
          end: "+=120%",
          scrub: 1,
        }
      })
    })
  })
}

// grid anim

// const gridItem = document.querySelectorAll("[item1]")
const gridItem = document.querySelectorAll(".grid-t-item")

const grid = document.querySelector("[grid1]")
const gridItem2 = document.querySelectorAll(".grid-t-item2")
const grid2 = document.querySelectorAll("[grid2]")

function gridAnim() {

  gsap.from(gridItem, {
    yPercent: 100,
    stagger: { amount: .5 },
    scrollTrigger: {
      trigger: ".hero",
      start: "bottom bottom",
      end: "+=200%",
      scrub: 1,
      // markers: true
    }
  })

  gsap.from(gridItem2, {
    yPercent: 200,
    delay: .2,
    stagger: { amount: .5, from: "random" },
    scrollTrigger: {
      trigger: ".grid-trigger",
      start: "bottom bottom",
      end: "+=250%",
      scrub: 1,
    }
  })
}
gridAnim();

function footer() {
  // ScrollTrigger.refresh();

  const fin = document.querySelectorAll("[fin]")
  var split = SplitText.create(fin, { types: "chars" })
  const chars = split.chars;
  const hover = document.querySelectorAll("[link-hover]")

  gsap.fromTo(chars, {
    yPercent: -110,
    rotateZ: 10,
  }, {
    yPercent: 0,
    stagger: .09,
    rotateZ: 0,
    scrollTrigger: {
      scrub: 1.1,
      trigger: ".footer",
      start: "top top",
      end: "+=80%",
      // markers: true
    }
  })

  hover.forEach((el) => {
    gsap.to(el, {
      duration: .7,
      scrambleText: {
        text: "{original}",
        chars: " ",
        speed: .6,
        tweenLength: false,
        rightToLeft: false,
      },
      scrollTrigger: {
        trigger: ".footer",
        start: "center center",
        // end: "+=100%",
        // markers: true
      }
    });

  });

  document.querySelectorAll("[link-hover]").forEach(hover => {
    const og = hover.textContent;

    hover.addEventListener('mouseenter', () => {
      gsap.to(hover, {
        duration: 0.4,
        scrambleText: {
          text: og,
          chars: " ",
          speed: 0.07,
          tweenLength: false,
        },

      });
    });
  })

  const button = document.querySelector(".top-button");

  button.addEventListener('click', () => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  });
}

function lenis() {
  let lenis = new Lenis({
    lerp: 0.11,
    wheelMultiplier: 0.72,
    gestureOrientation: "vertical",
    normalizeWheel: false,
    smoothTouch: false,
  });

  function raf(time) {
    lenis.raf(time);
    requestAnimationFrame(raf);
  }

  requestAnimationFrame(raf);

  $("[data-lenis-start]").on("click", function () {
    lenis.start();
  });

  $("[data-lenis-stop]").on("click", function () {
    lenis.stop();
  });

  $("[data-lenis-toggle]").on("click", function () {
    $(this).toggleClass("stop-scroll");
    if ($(this).hasClass("stop-scroll")) {
      lenis.stop();
    } else {
      lenis.start();
    }
  });
}
lenis()

function initScripts() {
  loader();
  nav();
  gauge();
  heading();
  gears();
  briefAnim();
  mile();
  analog()
  blueprint()
  legacy();
  footer()

}
initScripts();


